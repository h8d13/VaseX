#!/bin/bash

#main
#set -e # Debug line
## Helpers any POSIX compliant command
. ./util_f

parse_args "$@"
setup_cleanup

# Show help if requested
if exec_args "HELP"; then
    show_help
    exit 0
fi

# Load constants
if file_ex "./..."; then
    . ./...
fi
## Magic reset line
#rm -rf "${rel}${p_lib}"
if exec_args "RESET"; then
    postop "Resetting: removing ${rel}${p_lib}"
    rm -rf "${rel}${p_lib}"
fi
# Setup lib directory
dir_excreate "${rel}${p_lib}"
dir_excreate "${rel}${zl_d}/a"  # Create ISO dir 
dir_excreate "${rel}${zl_d}/d"  # Create ISO dir 
dir_excreate "${rel}${zl_d}/c" # Create Disks dir

# Awlays give these back to sudo user
chown_all "$SUDO_USER" "${rel}${zl_d}/d" && dir_own "${rel}${zl_d}/d" "$SUDO_USER" 
chown_all "$SUDO_USER" "${rel}${zl_d}/c" && dir_own "${rel}${zl_d}/c" "$SUDO_USER" 

# Create settings if not exist
if ! file_ex "${rel}${p_lib}/${c_file}.${c_ext}"; then
    preop "Creating ${rel}${p_lib}/${c_file}.${c_ext}"
    cat > "${rel}${p_lib}/${c_file}.${c_ext}" << 'EOF'
#FORMAT= # 1 Start enabled / 0 Start disabled
COLORS=1 # 0 Disables colors of all output
TIMING=1 # 0 Disables timing output of rcw
DEBUGS=1 # 0 Disables info outputs from program
TEELOG=1 # 0 Disables complete log file
LOGMEM=0 # 1 Enables keeping previous log
LOGCLR=0 # 1 Enables non standard ascii in log
CATART=1 # 0 Disables cli art sadface
EOF
else
    preop "Settings already exists. Skipping..."
fi
# Load settings > Linked to functionalities
if file_ex "${rel}${p_lib}/${c_file}.${c_ext}"; then
    . "${rel}${p_lib}/${c_file}.${c_ext}"
fi
# Create if not exists rcw
if ! file_ex "${rel}${p_lib}/${rcw_file}"; then
    preop "Creating ${rel}${p_lib}/${rcw_file}"
    cat > "${rel}${p_lib}/${rcw_file}" << 'EOF'
#!/bin/bash
#rcw
GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m'

info() {
    [ "${DEBUGS:-1}" = "1" ] && echo -e "${BLUE}[INFO]${NC} $*"
}
warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
reop() { echo -e "${GREEN}[OKAY]${NC} $*"; }
die() {
    echo -e "${RED}[ERROR]${NC} $*";
    exec 1>&- 2>&-
    wait
    exit 1
}
# Color-only functions (no tags) for inline use
c_green() { echo -e "${GREEN}$*${NC}"; }
c_red() { echo -e "${RED}$*${NC}"; }
c_cyan() { echo -e "${CYAN}$*${NC}"; }
time_c() { echo -e "${CYAN}$*${NC}"; }
get_usec() {
    date +%s%6N
}
fmt_dur() {
    local usec=$1
    local sec=$((usec / 1000000))
    local us=$((usec % 1000000))
    local ms=$((us / 1000))
    local us_only=$((us % 1000))
    if [ $sec -gt 0 ]; then
        printf "%d.%03ds" $sec $((us / 1000))
    elif [ $ms -gt 0 ]; then
        printf "%d.%03dms" $ms $us_only
    else
        printf "%dμs" $us
    fi
}
rcw() {
    local cmd="$*"
    [ "${DEBUGS}" = "1" ] && echo -e "${BLUE}[INFO]${NC} Running: $cmd"
    local t_start
    t_start=$(get_usec)
    eval "$cmd"
    local rc=$?
    local t_end
    t_end=$(get_usec)
    local dur=$((t_end - t_start))
    local check="✓"
    local cross="✗"
    local clock="【┘】"

    if [ "$TIMING" = "1" ]; then
        local t_str
        t_str=$(fmt_dur $dur)
        if [ "$COLORS" = "1" ]; then
            echo -e "$(c_cyan "[TIME]") ${t_str} ${clock}"
        else
            echo -e "[TIME] ${t_str} ${clock}"
        fi
    fi
    if [ $rc -eq 0 ]; then
        if [ "$COLORS" = "1" ]; then
            echo -e "$(c_green "[SUCCESS]") Exit: ${rc} ${check}"
        else
            echo -e "[SUCCESS] Exit: ${rc} ${check}"
        fi
    else
        if [ "$COLORS" = "1" ]; then
            echo -e "$(c_red "[ERROR]") Exit: ${rc} ${cross}"
        else
            echo -e "[ERROR] Exit: ${rc} ${cross}"
        fi
    fi
    return $rc
}
init_log() {
    if [ "$TEELOG" = "1" ]; then
        local log_file="${1:-./vase.log}"
        if [ "$LOGCLR" = "1" ]; then
            # Keep colors in log
            if [ "$LOGMEM" = "0" ]; then
                true > "$log_file"
            fi
            exec > >(tee -a "$log_file") 2>&1
        else
            # Strip colors from log
            if [ "$LOGMEM" = "0" ]; then
                true > "$log_file"
                exec > >(tee -a >(sed 's/\x1b\[[0-9;]*m//g' > "$log_file")) 2>&1
            else
                exec > >(tee -a >(sed 's/\x1b\[[0-9;]*m//g' >> "$log_file")) 2>&1
            fi
        fi
        info "Logging to: $log_file"
    fi
}
EOF
else
    preop "Rcw already exists. Skipping..."
fi
if file_ex "${rel}${vase_d}/${cli_a}" && [ "${CATART:-1}" = "1" ]; then
    nlp
    cat "${rel}${vase_d}/${cli_a}"
    nlp
fi
# Make exec
file_mex "${rel}${p_lib}/${rcw_file}"
# Check wrapper
if file_ex "${rel}${p_lib}/${rcw_file}"; then
    # Source wrapper
    . "${rel}${p_lib}/${rcw_file}"
    info "Loaded ${rcw_file} from ${rel}${p_lib}"
fi
# Skip logging for TUI mode (breaks curses) otherwise start log
if ! exec_args "TUI"; then
    init_log "${rel}${p_lib}/${log_n}.${log_ext}"
fi
if exec_args "UPDATE"; then
    git submodule update --init --recursive
    check_updates && exit
fi
if exec_args "GRUB"; then
    grub_args="$(get_grub_cmd)"
    # Extract first arg after -g flag
    grub_flag=$(echo "$grub_args" | awk '{print $2}')
    # Get remaining args
    grub_rest=$(echo "$grub_args" | cut -d' ' -f3-)
    if [ -z "$grub_flag" ]; then
        "./${gl_d}/grome_lum" -h && exit
    else
        "./${gl_d}/grome_lum" "$grub_flag" $grub_rest && exit
    fi
fi
if exec_args "BRANCH" || exec_args "BRANCH_TUI"; then
    branch_name="$(get_branch_name)"

    if [ -z "$branch_name" ]; then
        die "No branch name specified. Usage: -b <branch> or -bt <branch>"
    fi

    # Check if branch exists
    if ! git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
        die "Branch '$branch_name' does not exist"
    fi

    # Switch to branch
    preop "Switching to branch: $branch_name"
    git checkout "$branch_name" || die "Failed to switch to branch $branch_name"
    postop "Switched to branch: $(git branch --show-current)"

    # If -bt flag, set TUI flag so it gets picked up by TUI handler below
    if exec_args "BRANCH_TUI"; then
        TUI=1
        preop "Will launch TUI on branch: $branch_name"
        # Don't exit here, let it fall through to TUI handling below
    else
        exit
    fi
fi
if exec_args "EDIT_CONF"; then
    preop "Editing config file"
    $EDITOR ... && exit
fi
if exec_args "POST"; then
    post_type="$(get_post_type)"
    preop "Running post-install script: post_${post_type}..."
    "./${ka_d}/post_${post_type}" && exit
fi
if exec_args "POST_EDIT"; then
    post_edit_type="$(get_post_edit_type)"
    preop "Opening post-install script in $EDITOR: post_${post_edit_type}..."
    $EDITOR "./${ka_d}/post_${post_edit_type}" && exit
fi
if exec_args "PKG_MAN"; then
    preop "Launching PACTOPAC package manager..."
    gui_som "$SUDO_USER"
    python3 "./${pp_d}/main.py" && ./${cc_py} && exit
fi
if exec_args "EXTRACT_LOGS"; then
    preop "Extracting installer logs..."
    "./${hb_d}/extract_logs" extract && exit
fi
if exec_args "EXTRACT_LOGS_UPLOAD"; then
    preop "Extracting and uploading installer logs..."
    "./${hb_d}/extract_logs" upload && exit
fi
if im_groot; then
    # Tree output
    if cmd_exists "tree"; then
        info "Output dir strucs to .directory file..."
        tree_dir "$s_dir" # Outputs tree to .dir file conditional
    fi 
    if exec_args "KLARTIX"; then
        preop "Launching Klartix Artix Linux installer..."
        "./${vase_d}/klar_tix/klartix" && exit
    fi
    # Use reop for regular operation green output
    if im_sudo; then
        obanner "PERMS CHECK"
        info "Running as elevated user..."
        info "Session type: $(gui_what)"
        gui_som "$SUDO_USER" #export XDG for sudo user

        cbanner "PERMS CHECK"
        obanner "ENVIR CHECK"
        "./${vase_p_deps}"

        rcw "echo \"${vm_d}/: \$(du -sh \"./${zl_d}/${vm_d}/\" | cut -f1) (\$(find \"./${zl_d}/${vm_d}/\" -type f | wc -l))\""
        rcw "echo \"c/: \$(du -sh \"./${zl_d}/c/\" | cut -f1) (\$(find \"./${zl_d}/c/\" -type f | wc -l))\""

        cbanner "ENVIR CHECK"
        if exec_args "START"; then
            obanner "FILES CHECK"

            if ! file_ex "./${zl_d}/${vm_d}/${iso_n}.${iso_ext}"; then
                info "Looking for ./${zl_d}/${vm_d}/${iso_n}.${iso_ext}"
                die "ISO: $iso_n Not found in dir ${vm_d}. Build using -i or change ... config. Or get an ISO"
            else
                info "Found $iso_n in proper location."
            fi
            cbanner "FILES CHECK"
            . "./${vase_p_env}"
            preop "Starting VM Menu..."
            "./${zl_d}/vm_start" && exit
        fi
        if exec_args "QUICK"; then
            . "./${vase_p_env}"
            quick_arg="$(get_quick_cmd)"
            if ! file_ex "./${zl_d}/${vm_d}/${iso_n}.${iso_ext}"; then
                info "Looking for ./${zl_d}/${vm_d}/${iso_n}.${iso_ext}"
                warn "ISO: $iso_n Not found in dir ${vm_d}. Build using -i or change ... config. Or get an ISO"
            else
                info "Found $iso_n in proper location dir: ${vm_d}"
            fi
            if [ -z "$quick_arg" ]; then
                "./${zl_d}/vm_start" "__default__"
            else
                "./${zl_d}/vm_start" "$quick_arg"
            fi
            exit $?
        fi
        if exec_args "ISO"; then
            preop "Checking host is Up to Date..."
            "./${zl_d}/host_uptodate" || exit 1
            preop "Starting ISO Builder..."
            "./${zl_d}/iso_mod" && exit
        fi
        if exec_args "FLASH"; then
            flash_device="$(get_flash_device)"

            iso_file="./${zl_d}/${vm_d}/${iso_n}.${iso_ext}"
            if ! file_ex "$iso_file"; then
                die "ISO not found: $iso_file"
            fi
            preop "Flashing ISO to device..."
            "./${zl_d}/flash_iso" "$iso_file" "$flash_device" && rcw true && exit
        fi
        if exec_args "WORKFLOW"; then
            all_device="$(get_workflow_device)"
            preop "Starting ISO workflow..." # Check happens in util_f

            # Build ISO
            preop "Checking host is Up to Date..."
            "./${zl_d}/host_uptodate" || exit 1
            preop "Building ISO..."
            "./${zl_d}/iso_mod" || exit 1

            preop "Signing ISO..."
            sudo -u "$SUDO_USER" "./${zl_d}/gen_sig"

            # Verify signature
            preop "Verifying signature..."
            gpg_info=$(sudo -u "$SUDO_USER" "./${zl_d}/ver_sig" | tail -n 1)

            # Flash ISO
            iso_file="./${zl_d}/${vm_d}/${iso_n}.${iso_ext}"
            preop "Flashing ISO to $all_device..."
            "./${zl_d}/flash_iso" "$iso_file" "$all_device" 

            # Log to test.status
            test_date=$(date '+%Y-%m-%d %H:%M:%S')
            # Get raw bytes and convert to GiB
            iso_bytes=$(stat -c%s "$iso_file" 2>/dev/null || echo 0)
            iso_size=$(bytes_to_gib "$iso_bytes")
            if [ "${dev_mode:-0}" = "1" ]; then
                echo "${test_date} | Version: ${vase_v} | ISO: ${iso_n}.${iso_ext} | Size: ${iso_size} | GPG: ${gpg_info} | Status: DEV" >> tests.status
            else
                echo "${test_date} | Version: ${vase_v} | ISO: ${iso_n}.${iso_ext} | Size: ${iso_size} | GPG: ${gpg_info} | Status: OK" >> tests.status
            fi
            
            chown "$SUDO_USER:$SUDO_USER" tests.status README.md || true

            reop "All workflow finished! Change Status to FAIL in tests.status if physical test fails."
            exit
        fi
        if dir_own "${rel}${p_lib}" "root"; then
            ## Give back to user
            info "Changing ownership from root to $SUDO_USER"
            chown_all "$SUDO_USER" "${rel}${p_lib}"
            # Verify we actually gave back
            dir_own "${rel}${p_lib}" "$SUDO_USER" || die "Failed to switch ownership"
        else
            info "Skipping... file already owned by $SUDO_USER"
        fi
    else
        reop "Running as root. Skipping..."
    fi
else
    if am_iuser; then
        die "Running as regular user." # Or warn and do smthn else
    fi
fi