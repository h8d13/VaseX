#!/bin/bash
#utilities
show_help() {
    cat << 'EOF'
VaseOS - Arch Linux KDE Testing Suite

Usage: ./main [OPTIONS]

Options:
  -h,  --help                Show this help message
  -u,  --update              Check git for updates & pull submodules
  -ec, --edit-conf           Edit configuration file (...)

  -b,  --branch BRANCH       Switch to git branch

  -pe, --post-edit <type>    Edit post install script (plasma/gnome/xfce4, default: plasma)
  -p,  --post <type>         Run post install script (plasma/gnome/xfce4, default: plasma)
  -pm, --pkg-man             Launch pacman GUI

  -s,  --start               Start VM menu
  -q,  --quick <command>     Pass direct VM options (use "help" for list)
  -i,  --isomod              Create ISO using iso_profiles/plasma_skinny.conf
  -f,  --flash <device>      Flash ISO to USB device (e.g., /dev/sdd)
  -w,  --workflow <device>   Complete workflow: build, sign, flash
  -g,  --grub <args>         GRUB utilities (-h for grub help)
  -b,  --bench <type>        Run benchmarks: io, cpu, gpu
  -k,  --klartix             Launch Klartix Artix Linux installer
  -r,  --reset               Reset logs and settings

Examples:

  ./main -i                  Build ISO
  ./main -k                  Launch Klartix installer
  ./main -q help             Show VM quick commands
  ./main -w /dev/sdd         Build ISO, sign, and flash to USB

EOF
}
parse_args() {
    # If no args, show help
    if [ $# -eq 0 ]; then
        HELP=1
        return
    fi

    while [ $# -gt 0 ]; do
        case $1 in
            -h|--help)
                HELP=1
                shift
                ;;
            -r|--reset)
                RESET=1
                shift
                ;;
            -s|--start)
                START=1
                shift
                ;;
            -i |--isomod)
                ISO=1
                shift
                ;;
            -q|--quick)
                QUICK=1
                if [ -n "$2" ] && [[ ! "$2" == -* ]]; then
                    QUICK_CMD="$2"
                    shift 2
                else
                    QUICK_CMD=""
                    shift
                fi
                ;;
            -u|--update)
                UPDATE=1
                shift
                ;;
            -b|--branch)
                BRANCH=1
                BRANCH_NAME="$2"
                shift 2
                ;;
            -f|--flash)
                FLASH=1
                FLASH_DEVICE="$2"
                if [ -z "$flash_device" ]; then
                    lsblk
                    echo "No device specified. Use: -f /dev/sdX"
                    exit 1
                fi
                shift 2
                ;;
            -w|--workflow)
                WORKFLOW=1
                if [ -z "$2" ] || [[ "$2" == -* ]]; then
                    lsblk
                    echo "Error: -w requires a device argument (e.g., /dev/sdd)"
                    exit 1
                fi
                WORKFLOW_DEVICE="$2"
                shift 2
                ;;
            -g|--grub)
                GRUB=1
                # Capture all remaining args for grome_lum
                GRUB_CMD="$*"
                shift
                break
                ;;
            -p|--post)
                POST=1
                if [ -n "$2" ] && [[ ! "$2" == -* ]]; then
                    POST_TYPE="$2"
                    shift 2
                else
                    POST_TYPE="plasma"
                    shift
                fi
                ;;
            -pe|--post-edit)
                POST_EDIT=1
                if [ -n "$2" ] && [[ ! "$2" == -* ]]; then
                    POST_EDIT_TYPE="$2"
                    shift 2
                else
                    POST_EDIT_TYPE="plasma"
                    shift
                fi
                ;;
            -pm|--pkg-man)
                PKG_MAN=1
                shift
                ;;
            -ec|--edit-conf)
                EDIT_CONF=1
                shift
                ;;
            -k|--klartix)
                KLARTIX=1
                shift
                ;;
            *)
                echo "Unknown option: $1"
                echo "Run './main -h' for help"
                exit 1
                ;;
        esac
    done
}
exec_args() {
    case "$1" in
        HELP) [ "${HELP}" = "1" ] ;;
        RESET) [ "${RESET}" = "1" ] ;;
        START) [ "${START}" = "1" ] ;;
        ISO) [ "${ISO}" = "1" ] ;;
        TUI)  [ "${TUI}" = "1" ] ;;
        QUICK) [ "${QUICK}" = "1" ] ;;
        UPDATE) [ "${UPDATE}" = "1" ] ;;
        BRANCH) [ "${BRANCH}" = "1" ] ;;
        FLASH) [ "${FLASH}" = "1" ] ;;
        WORKFLOW) [ "${WORKFLOW}" = "1" ] ;;
        GRUB) [ "${GRUB}" = "1" ] ;;
        POST) [ "${POST}" = "1" ] ;;
        POST_EDIT) [ "${POST_EDIT}" = "1" ] ;;
        PKG_MAN) [ "${PKG_MAN}" = "1" ] ;;
        EDIT_CONF) [ "${EDIT_CONF}" = "1" ] ;;
        KLARTIX) [ "${KLARTIX}" = "1" ] ;;
        *) return 1 ;;
    esac
}
get_edit_conf_cmd() {
    echo "${EDIT_CONF}"
}
get_quick_cmd() {
    echo "${QUICK_CMD}"
}
get_tui_cmd() {
    echo "${TUI_CMD}"
}
get_branch_name() {
    echo "${BRANCH_NAME}"
}
get_flash_device() {
    echo "${FLASH_DEVICE}"
}
get_workflow_device() {
    echo "${WORKFLOW_DEVICE}"
}
get_grub_cmd() {
    echo "${GRUB_CMD}"
}
get_post_type() {
    echo "${POST_TYPE}"
}
get_post_edit_type() {
    echo "${POST_EDIT_TYPE}"
}
bytes_to_gib() {
    local bytes="$1"
    awk "BEGIN {printf \"%.1fGiB\", $bytes/1024/1024/1024}"
}
preop() {
    echo "[+] $1"
}
nlp() {
    echo ""
}
postop() {
    echo "[-] $1"
}
setup_cleanup() {
    trap cleanup EXIT INT TERM
}
cleanup() {
    if [ -n "$script_s" ] && [ "${TIMING}" = "1" ]; then
        local script_end
        script_end=$(date +%s%6N)
        local total_dur=$((script_end - script_s))

        # Format the duration
        local sec=$((total_dur / 1000000))
        local us=$((total_dur % 1000000))
        local ms=$((us / 1000))

        if [ $sec -gt 0 ]; then
            postop "Runtime: ${sec}.$(printf '%03d' $((us / 1000)))s"
        elif [ $ms -gt 0 ]; then
            postop "Runtime: ${ms}ms"
        else
            postop "Runtime: ${us}Î¼s"
        fi
    fi
    postop "Cleaning up..."
    # Add cleanup stuff here
}
to_devnull(){
    "$@" >/dev/null 2>&1
}
silent_err(){
    "$@" 2>/dev/null
}
file_ex() {
    [ -f "$1" ]
}
file_mex() {
    if file_ex "$1"; then
       chmod +x "$1"
    fi
}
file_excreate() {
    if ! file_ex "$1"; then
        touch "$1"
    fi
}
dir_ex() {
    [ -d "$1" ]
}
dir_excreate() {
    if ! dir_ex "$1"; then
        mkdir -p "$1"
    fi
}
im_groot() {
    [ "$EUID" -eq 0 ]
}
am_iuser() {
    [ "$EUID" -ne 0 ]
}
im_sudo() {
    [ -n "$SUDO_USER" ]
}
gui_what() {
    if [ -n "$SUDO_USER" ]; then
        local user_pid
        user_pid=$(pgrep -u "$SUDO_USER" -n)
        silent_err grep -z "^XDG_SESSION_TYPE=" /proc/"$user_pid"/environ | cut -d= -f2 | tr -d '\0'
    else
        echo "${XDG_SESSION_TYPE}"
    fi
}
gui_som() {
    local user="${1:-$SUDO_USER}"
    local runtime_dir="/run/user/$(id -u "$user")"

    export XDG_RUNTIME_DIR="$runtime_dir"
    export DBUS_SESSION_BUS_ADDRESS="unix:path=${runtime_dir}/bus"
    export WAYLAND_DISPLAY="${WAYLAND_DISPLAY:-wayland-1}"  
    export DISPLAY="$DISPLAY"  
    export XAUTHORITY=$XAUTHORITY
}
chown_all() {
    chown -R "$1:$1" "$2"
}
who_dir() {
    stat -c '%U' "$1"
}
dir_own() {
    [ "$(who_dir "$1")" = "$2" ];
}
cmd_exists() {
    command -v "$1" >/dev/null 2>&1
}
cmd_check() {
    local cmd="$1"
    if cmd_exists "$cmd"; then
        reop "Found: $cmd"
        return 0
    else
        warn "Missing: $cmd"
        return 1
    fi
}
obanner() {
    echo "=== [$1] ==="
}
cbanner() {
    local label="$1"
    local banner_len=$((${#label} + 10))
    local i=0
    while [ $i -lt $banner_len ]; do
        printf '='
        i=$((i + 1))
    done
    echo
}
check_updates() {
    local repo_url="https://github.com/h8d13/Vase"

    preop "Checking for updates..."

    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        warn "Not a git repository. Clone from ${repo_url}"
        return 1
    fi

    local local_hash=$(git rev-parse HEAD 2>/dev/null)
    if [ -z "$local_hash" ]; then
        warn "Failed to get local commit hash"
        return 1
    fi

    preop "Fetching from GitHub..."
    if ! GIT_TERMINAL_PROMPT=0 git fetch https://github.com/h8d13/Vase.git master --quiet 2>/dev/null; then
        warn "Failed to fetch updates. Check network connection."
        warn "Alternatively, run: git fetch origin master"
        return 1
    fi

    local remote_hash=$(git rev-parse FETCH_HEAD 2>/dev/null)

    if [ -z "$remote_hash" ]; then
        warn "Failed to get remote commit hash"
        return 1
    fi

    if [ "$local_hash" = "$remote_hash" ]; then
        reop "Already up to date! (${local_hash:0:8})"
        return 0
    fi

    warn "Updates available!"
    echo ""
    echo "Current: ${local_hash:0:8}"
    echo "Latest:  ${remote_hash:0:8}"
    echo ""
    echo "Changes:"
    git log --oneline --decorate --color=always HEAD..FETCH_HEAD | head -10
    echo ""
    echo "To update run: git pull in project root or view diff git log"
    return 0
}
tree_dir() {
    if ! dir_ex "$1"; then
        return 1
    fi

    local current_tree=$(tree -a --dirsfirst --gitignore -I '.git|.md5' "$1" 2>/dev/null)
    local current_hash=$(echo "$current_tree" | md5sum | awk '{print $1}')
    local stored_hash=""

    if file_ex "$1/.directory"; then
        stored_hash=$(grep "^# th: " "$1/.directory" 2>/dev/null | awk '{print $3}')
    fi

    if [ "$current_hash" != "$stored_hash" ]; then
        {
            echo "[Desktop Entry]"
            echo "Icon=folder-log"
            echo "# th: $current_hash"
            echo ""
            echo "$current_tree" | tail -n +2
        } > "$1/.directory"
    fi
}
